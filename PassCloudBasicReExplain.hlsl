struct _13
{
    float _m0;
};


struct _14
{
    float _m0;
    float _m1;
    float _m2;
    float _m3;
    float _m4;
};


struct _15
{
    float4 _m0;
    float4 _m1;
    float4 _m2;
    float4 _m3;
    float4 _m4;
    _14 _m5;
};


struct _16
{
    float4 _m0;
    float4 _m1;
    row_major float4x4 _m2;
};


struct _18
{
    float4 _m0;
    float4 _m1;
};


struct _19
{
    float4 _m0;
    float4 _m1;
    float4 _m2;
    float4 _m3;
    float4 _m4;
    float4 _m5;
    float4 _m6;
};


struct _20
{
    float _m0;
    float _m1;
    float _m2;
    float _m3;
    float _m4;
    float _m5;
    float _m6;
};


struct _22
{
    _16 _m0[2];
    _18 _m1;
    _19 _m2;
    _20 _m3;
    float4 _m4[3];
    float2 _m5;
    float2 _m6;
    float2 _m7;
    float _m8;
    float4 _m9[4];
    float2 _m10;
    float2 _m11;
    float4 _m12;
    float4 _m13;
    float4 _m14;
    float4 _m15[4];
    float _m16;
    int _m17;
    float _m18;
    float _m19;
};


struct _23
{
    float _m0;
    float _m1;
    float _m2;
    float _m3;
    float _m4;
    float _m5;
    float _m6;
    float _m7;
    float _m8;
    float _m9;
    float _m10;
    float _m11;
};


struct _24
{
    float _m0;
    float _m1;
    float _m2;
};


struct _25
{
    float _m0;
    float _m1;
    float _m2;
    float _m3;
    float3 _m4;
    int _m5;
};


struct _26
{
    _23 _m0;
    _24 _m1;
    _25 _m2;
    float2 _m3;
    float2 _m4;
    float4 _m5;
    float _m6;
    float _m7;
    uint _m8;
    float _m9;
    float _m10;
    float _m11;
    float _m12;
    float _m13;
    float _m14;
    float _m15;
    float _m16;
    float _m17;
};


struct _28
{
    float4 _m0[5];
};


struct _30
{
    float _m0;
    float _m1;
    float _m2;
    float _m3;
    float _m4;
    float _m5;
};


struct _31
{
    float _m0;
    float _m1;
    float _m2;
    float _m3;
};


struct _33
{
    int _m0;
    int _m1;
};


struct _34
{
    float _m0;
    float _m1;
    float _m2;
    float _m3;
    float _m4;
    float _m5;
    float2 _m6;
    float _m7;
    float _m8;
    float _m9;
    float _m10;
};


struct _35
{
    float _m0;
    float4 _m1;
    float _m2;
    float4 _m3;
    uint4 _m4;
    uint4 _m5;
    float4 _m6;
    int _m7;
    int _m8;
    int _m9;
    float4 _m10;
    float4 _m11[8];
    uint _m12;
    float3 _m13;
    float3 _m14;
    float2 _m15;
    float2 _m16;
    row_major float3x3 _m17;
    float3 _m18;
    float3 _m19;
    float _m20;
    float _m21;
    float3 _m22;
    float3 _m23;
    float3 _m24;
    float3 _m25;
    float4 _m26[13];
    int _m27;
    float4 _m28;
    float4 _m29;
    float4 _m30;
    float3 _m31;
    float3 _m32;
    float3 _m33;
    float3 _m34;
    float4 _m35;
    float _m36;
    float _m37;
    float _m38;
    float _m39;
    row_major float4x4 _m40;
    _13 _m41;
    _15 _m42;
    _22 _m43;
    _26 _m44;
    _28 _m45;
    _30 _m46;
    _31 _m47[5];
    float4 _m48;
    _33 _m49;
    float4 _m50;
    _34 _m51;
};


struct _39
{
    float _m0;
    float3 _m1;
    float3 _m2;
    float3 _m3;
    float _m4;
    float3 _m5;
    float3 _m6;
    float _m7;
    float3 _m8;
    float3 _m9;
    float2 _m10;
    float3 _m11;
    float4 _m12;
    float4 _m13[4];
    float4 _m14;
    float _m15;
    int _m16;
};


struct _40
{
    float _m0;
};


struct _41
{
    float _m0;
    float _m1;
    float _m2;
    float _m3;
    float _m4;
    float _m5;
    uint _m6;
    uint _m7;
    uint4 _m8;
};


struct _42
{
    float4 _m0;
    float4 _m1;
    float4 _m2;
    _41 _m3;
    float2 _m4;
};


struct _43
{
    float _m0;
    float _m1;
    float _m2;
    float _m3;
};


struct _44
{
    int _m0;
};


struct _45
{
    _44 _m0;
    float _m1;
    float _m2;
    float _m3;
};


struct _46
{
    float3 _m0;
    float3 _m1;
    float _m2;
    float _m3;
    _43 _m4;
    float _m5;
    float _m6;
    float _m7;
    float _m8;
    float _m9;
    float _m10;
    float _m11;
    float _m12;
    float _m13;
    float _m14;
    uint _m15;
    _44 _m16;
    _44 _m17;
    _45 _m18;
    float4 _m19;
    float _m20;
    float _m21;
    float _m22;
    float _m23;
    float _m24;
    float _m25;
    float _m26;
    float _m27;
};


struct _47
{
    float3 _m0;
    float _m1;
};


struct _48
{
    float4 _m0;
    float4 _m1;
    float4 _m2;
};


struct _49
{
    float2 _m0;
    float2 _m1;
    float _m2;
    float _m3;
    float _m4;
    float _m5;
    float _m6;
    float _m7;
    float2 _m8;
    float _m9;
};


struct _50
{
    float _m0;
    _44 _m1;
};


struct _51
{
    float _m0;
    float _m1;
    float _m2;
    float _m3;
    float _m4;
    float _m5;
};


struct _52
{
    _44 _m0;
    float _m1;
    float _m2;
};


struct _53
{
    int _m0;
};


struct _54
{
    _44 _m0;
    _53 _m1;
    _53 _m2;
};


struct _55
{
    _44 _m0;
};


struct _56
{
    _47 _m0;
    float4 _m1;
    row_major float4x4 _m2;
    row_major float4x4 _m3;
    _48 _m4;
    _49 _m5;
    _50 _m6;
    _51 _m7;
    _52 _m8;
    _54 _m9;
    _55 _m10;
    float _m11;
    float _m12;
    float _m13;
};


struct _57
{
    float _m0;
    float _m1;
    float2 _m2;
    float2 _m3;
    float2 _m4;
    float _m5;
    float _m6;
    float _m7;
    float _m8;
    float _m9;
    float _m10;
};


struct _58
{
    float4 _m0;
    float4 _m1;
    float4 _m2;
    float3 _m3;
    float3 _m4;
    float3 _m5;
    float3 _m6;
    float3 _m7;
};


struct _60
{
    float4 _m0;
    float4 _m1;
    float3 _m2;
};


struct _72
{
    float4 _m0;
    float4 _m1;
};


struct _76
{
    float _m0;
    float _m1;
    float _m2;
    float _m3;
    float _m4;
    float _m5;
    float _m6;
    float _m7;
    float _m8;
};


struct _93
{
    float _m0;
    float _m1;
    float _m2;
    float _m3;
    float _m4;
    float _m5;
    float _m6;
    float _m7;
    float _m8;
    float _m9;
    float _m10;
    float _m11;
    float _m12;
    float _m13;
    float _m14;
    float _m15;
    float _m16;
    float _m17;
    float _m18;
    _76 _m19[2];
};


struct _94
{
    float2 _m0;
    float2 _m1;
    float2 _m2;
    float _m3;
    float _m4;
    float _m5;
    float2 _m6;
};


struct _95
{
    float4 _m0;
    float4 _m1;
    float2 _m2;
    float _m3;
    float _m4;
    float _m5;
};


struct _96
{
    float3 _m0;
    float _m1;
    float _m2;
};


struct _97
{
    float _m0[32];
    float _m1[32];
    _39 _m2;
    _39 _m3;
    _40 _m4;
    _42 _m5;
    _46 _m6;
    _56 _m7;
    _57 _m8;
    _58 _m9;
    float _m10;
    float2 _m11;
    _60 _m12;
    _72 _m13;
    float _m14;
    float _m15;
    float4 _m16;
    _93 _m17;
    _94 _m18;
    _95 _m19;
    float4 _m20;
    float _m21;
    uint _m22;
    uint2 _m23;
    uint2 _m24;
    uint _m25;
    float _m26;
    float _m27;
    float _m28;
    float _m29;
    _96 _m30;
    int _m31;
};


cbuffer _8_9 : register(b29)
{
    row_major float4x4 _9_m0 : packoffset(c0);
    row_major float4x4 _9_m1 : packoffset(c4);
    row_major float4x4 _9_m2 : packoffset(c8);
    row_major float4x4 _9_m3 : packoffset(c12);
    float4 _9_m4 : packoffset(c16);
    row_major float4x4 _9_m5 : packoffset(c17);
    row_major float4x4 _9_m6 : packoffset(c21);
    row_major float4x4 _9_m7 : packoffset(c25);
};


ByteAddressBuffer _29 : register(t98);
ByteAddressBuffer _59 : register(t99);
ByteAddressBuffer _61 : register(t108);
cbuffer _103_73 : register(b23)
{
    float4 _73_m0[16] : packoffset(c0);
    float4 _73_m1 : packoffset(c16);
    float4 _73_m2 : packoffset(c17);
    float4 _73_m3 : packoffset(c18);
    float4 _73_m4 : packoffset(c19);
    float _73_m5 : packoffset(c20);
    float _73_m6 : packoffset(c20.y);
    float2 _73_m7 : packoffset(c20.z);
    float4 _73_m8 : packoffset(c21);
    float4 _73_m9 : packoffset(c22);
    float4 _73_m10 : packoffset(c23);
    float4 _73_m11 : packoffset(c24);
    row_major float4x4 _73_m12 : packoffset(c25);
    row_major float4x4 _73_m13 : packoffset(c29);
};


cbuffer _107_77 : register(b20)
{
    float4 _77_m0 : packoffset(c0);
    float4 _77_m1 : packoffset(c1);
    float4 _77_m2 : packoffset(c2);
    float4 _77_m3[6] : packoffset(c3);
    float4 _77_m4[6] : packoffset(c9);
    float4 _77_m5[6] : packoffset(c15);
    float4 _77_m6 : packoffset(c21);
    float4 _77_m7 : packoffset(c22);
    float4 _77_m8 : packoffset(c23);
    float4 _77_m9 : packoffset(c24);
    float4 _77_m10 : packoffset(c25);
    float4 _77_m11 : packoffset(c26);
    float4 _77_m12 : packoffset(c27);
    float4 _77_m13 : packoffset(c28);
    float4 _77_m14 : packoffset(c29);
    float4 _77_m15 : packoffset(c30);
    float4 _77_m16 : packoffset(c31);
    float4 _77_m17 : packoffset(c32);
    float4 _77_m18 : packoffset(c33);
    float4 _77_m19 : packoffset(c34);
    float4 _77_m20 : packoffset(c35);
    float4 _77_m21 : packoffset(c36);
    float4 _77_m22 : packoffset(c37);
    float4 _77_m23 : packoffset(c38);
    float4 _77_m24 : packoffset(c39);
    float4 _77_m25 : packoffset(c40);
    float4 _77_m26 : packoffset(c41);
    float4 _77_m27 : packoffset(c42);
    float4 _77_m28 : packoffset(c43);
    float4 _77_m29 : packoffset(c44);
    float4 _77_m30[2] : packoffset(c45);
    float4 _77_m31[2] : packoffset(c47);
    float4 _77_m32[2] : packoffset(c49);
    float4 _77_m33[2] : packoffset(c51);
    float4 _77_m34[2] : packoffset(c53);
    float4 _77_m35[2] : packoffset(c55);
    float4 _77_m36 : packoffset(c57);
    float4 _77_m37 : packoffset(c58);
    float4 _77_m38 : packoffset(c59);
    float4 _77_m39 : packoffset(c60);
    float4 _77_m40 : packoffset(c61);
    float4 _77_m41 : packoffset(c62);
    float4 _77_m42 : packoffset(c63);
    float4 _77_m43 : packoffset(c64);
    float4 _77_m44 : packoffset(c65);
    float4 _77_m45 : packoffset(c66);
    float4 _77_m46 : packoffset(c67);
    float4 _77_m47 : packoffset(c68);
    float4 _77_m48 : packoffset(c69);
    float4 _77_m49 : packoffset(c70);
    float4 _77_m50 : packoffset(c71);
    float4 _77_m51 : packoffset(c72);
    float4 _77_m52 : packoffset(c73);
    float4 _77_m53 : packoffset(c74);
    float4 _77_m54 : packoffset(c75);
    float4 _77_m55 : packoffset(c76);
    float4 _77_m56 : packoffset(c77);
    float4 _77_m57 : packoffset(c78);
    float4 _77_m58 : packoffset(c79);
    float4 _77_m59 : packoffset(c80);
    float4 _77_m60 : packoffset(c81);
    float4 _77_m61 : packoffset(c82);
    float4 _77_m62 : packoffset(c83);
    float4 _77_m63 : packoffset(c84);
    float4 _77_m64 : packoffset(c85);
    uint4 _77_m65[16] : packoffset(c86);
    row_major float4x4 _77_m66 : packoffset(c102);
    float4 _77_m67 : packoffset(c106);
    float4 _77_m68[6] : packoffset(c107);
};


SamplerState _5 : register(s33);
SamplerState _6 : register(s34);
SamplerState _7 : register(s36);
Texture3D<float4> _64 : register(t110);
Texture3D<float4> _65 : register(t111);
Texture3D<float4> _66 : register(t112);
Texture3D<float4> _67 : register(t113);
Texture2D<float4> _68 : register(t116);
Texture2DArray<float4> _70 : register(t121);
Texture2D<float4> _71 : register(t128);
SamplerState _74 : register(s37);
Texture2D<float4> _75 : register(t134);
Texture3D<float4> _78 : register(t159);
Texture2D<float4> _79 : register(t160);
Texture2D<float4> _80 : register(t161);
Texture2D<float4> _81 : register(t162);
Texture2D<float4> _82 : register(t163);
SamplerState _83 : register(s42);
RWTexture2D<float4> _85 : register(u64);
RWTexture2D<float> _87 : register(u66);
Texture3D<float4> _88 : register(t169);
Texture2D<float4> _89 : register(t173);


static uint3 gl_GlobalInvocationID;
struct SPIRV_Cross_Input
{
    uint3 gl_GlobalInvocationID : SV_DispatchThreadID;
};


static float4 _273;


void comp_main()
{
    //地球半径 6360km = 6360 000 m = 636000  单位 10m
    //地球半径 6371km /2 = 3185500 m = 318000 * 10m
    //对应的贴图输出大小 480 * 272
    //gl_GlobalInvocationID.x [60 * 8 =  0 ~ 480]
    //gl_GlobalInvocationID.y [34 * 8 =  0 ~ 272]

    float3 _280 = float3(asfloat(_29.Load4(1796)).zw, -318000.0f);        //对应的单位为10m //地球的球心

    uint _284 = gl_GlobalInvocationID.x * 2u;               // 2x
    uint _286 = gl_GlobalInvocationID.y * 2u;               // 2y
    uint _287 = _284 + 1u;                                  // 2x + 1
    uint _288 = _286 + 1u;                                  // 2y + 1
    uint2 _293[4] = { uint2(_284, _286), uint2(_287, _286), uint2(_287, _288), uint2(_284, _288) };
                    // [2x, 2y] [2x+1, 2y] [2x+1, 2y+1] [2x, 2y+1]

    uint2 _275[4] = _293;


    float4 _295 = _89.Load(int3(gl_GlobalInvocationID.xy, 0u));          //对应的一张Mask 1/4分辨率 Mask 贴图
    uint _297 = uint(_295.x);                                            //Mask贴图的X通道  , 记录之上的Offset 0 为1/2分辨率的原点，  1为1/2分辨率的右端， 2为1/2分辨的右下方， 3为1/2分辨率左下方
    float _300 = _295.y;                                                 //Mask贴图的Y通道  ，记录经过修正之后的SceneZ


    //_77_m15.xyzw  1/2分辨率贴图的大小  = [ 1/w, 1/h, w , h ]  [1/960, 1/540, 960, 540]       
    float2 _306 = (float2(_275[_297]) + 0.5f.xx) * _77_m15.xy;          //对应的实际的半分辨率下的 UV
    float3 _311 = float3((_306 * float2(2.0f, -2.0f)) - float2(1.0f, -1.0f), 1.0f);   // 半分辨率下的NDC xy， NDC1

    float _323 = dot(_311, _77_m11.xyz);                                            //TranslatedWorldViewDirZ
    float3 _324 = float3(dot(_311, _77_m9.xyz), dot(_311, _77_m10.xyz), _323);      //NDC To WorldSpaceViewDir



    bool _325 = _300 > 1.0f;                                             //Mask 贴图Y通道是否大一1， 对应的范围为是否为天空 天空为2



    float _328 = _300 * _77_m14.y;                                       //_300 * _77_m14.y(5000) 对应的Mask 贴图所使用的高度系数   SceneZ
    float _329 = _325 ? 636000.0f : _328;                                //天空？ 636000， :  SceneZ    //对应的SceneZ 单位是10m计算


    float2 _349 = abs((_306 * 2.0f) - 1.0f.xx);                         //实际半分辨率的重新映射【1，0】【0，1】


    float _361 = frac(
                        _70.Load(
                                    int4(int4(
                                                int2(
                                                        _275[_297]          //从对应的Mask贴图的X通道获得一个 1/2分辨率的贴图所在的位置, 然后将其位置进行取模运算
                                                    ) & int2(63, 63),       //一个块内 32 * 32, 对应取出来的值 可能为 [0-63],[0-63]的值
                                                    0, 0
                                            ).xyz, 0
                                        )
                                ).x                                         //从_70贴图当中去读取对应的值,对应的贴图为64*64 的一张噪声贴图
                                
                                    + ( float(uint(int(_77_m50.x))) * 1.61803400516510009765625f) //+ 对应的_77_m50.x 对应的 * 黄金分割值

                    ) * lerp(
                                _77_m31[1].w, //1
                                _77_m32[1].w, //1
                                
                                clamp(
                                        //0.5 - 0.75
                                        (max(_349.x, _349.y) - 0.5f) * 4.0f,

                                        0.0f, 
                                        1.0f
                                    )
                            );
    
    float4 _1543;
    float _1544;
    float _1545;


    //基准云层范围测试
    //_77_m50 = [0, 1000, 160, 8]
    [branch]
    if (_77_m50.z < _329)                //1600米 《= 对应的高度米
    {
        float _370 = abs(_323);                     //abs(ViewZ)
        float3 _378 = -_9_m4.xyz;                   //ViewOrgin

        //_77_m27 = [200, 1240 0.00096 319240]      //TopLevelSphere
        float _381 = 318000.0f + _77_m27.y;         //水平面上高度为12400 米 的大气TopBoundary  ==  C
        float3 _382 = _378 - _280;                  //ViewOrgin - SphereCenter      == A    //计算ViewOrigin 在新的坐标下的位置。 新的坐标系的原点 _280//WorldSpace

                                                    // 324 = B 
        float _383 = dot(_324, _324);               // |B|^2
        float _384 = dot(_382, _324);               // |A|B|*costheaa

        float _385 = 2.0f * _384;                   //2|A|B|costheta
        float _392 = (_385 * _385) - (
                                        (4.0f * _383) * (
                                                            dot(_382, _382) - (_381 * _381)
                                                            //|A|^2 - |C|^2
                                                        )
                                         //4 * |B|^2 *( |A|^2 - |C|^2)
                                    );

                    //4|A|^2|B|^2 *costheta * costheata   - 4 * |B|^2 * (|A|^2 - |C|^2)

        //4|B|^2 * ( |A|costheta)^2 - (|A|^2 - |C|^2)） >=0    C^2 - A^2Sinthea^2
        // C^2 >= A^2 sintheat^2   == 

        //D^2 + (V^2 - k^2) + 2vd*costheat = 0;
        //有解的Delta = （2vcosthea)^2 - 4(V^2 - k^2) >=0 


        float2 _405;
        if (_392 < 0.0f)                        //说明Delta 》=0 ，存在解析解
        {
            _405 = (-1.0f).xx;
        }
        else
        {
            float _397 = sqrt(_392);                                        //
            float _398 = _384 * (-2.0f);                                    //-2|A|B|costheta
            _405 = float2(_398 - _397, _398 + _397) / (2.0f * _383).xx;     //-2|A|B|costheta - 2|B| * (C^2-A^2sintheta^2)^1/2
        }



        float _409 = min(_329, max(_405.x, _405.y));                       //当前ViewOrin 距离大气边缘的距离 对应的经过修正之后的SceneZ，其中的最大值。
        float _421;

        if (_323 < 0.0f)    //视线朝向下方
        {
            _421 = min(
                        _409, 

                        //_29.Load(364) = 
                        (_378.z - asfloat(_29.Load(364))) / max(-_323, 9.9999999747524270787835121154785e-07f) );
                        //ViewOrigin.Z - T / max(-323， )

                    //再次进行对应的位置修正，视线朝向下方的过程中， 其最大的距离不超过 ViewHeight 朝着对应的角度碰撞到地表的距离
        }
        else                //视线朝向上方
        {
            _421 = _409;
        }

        float _424 = min(_421, _77_m37.w);  //同时设定最大的大气厚度的距离， 公司版本为 22000
        float3 _429 = normalize(_324);      //Normalized TranslatedViewDir


        //_77_m49.xyz = 当前的
        float _434 = clamp(dot(_77_m49.xyz, _429), -1.0f, 1.0f);    //Costheta


        float _437 = _77_m48.y * _77_m48.y;
        float _445 = 0.079577468335628509521484375f * ((1.0f - _437) / pow((1.0f + _437) - ((2.0f * _77_m48.y) * _434), 1.5f));
        float _448 = _77_m48.y * 0.666666686534881591796875f;
        float _449 = _448 * _448;
        float _458 = (0.079577468335628509521484375f * ((1.0f - _449) / pow((1.0f + _449) - ((_77_m48.y * 1.33333337306976318359375f) * _434), 1.5f))) * _77_m48.x;

        float _459 = _424 - _77_m50.z;  //最大可以检测的距离 - Ray Intersect

                                                            //将可以检测的最大距离进行分块，
                                                            // _459 / max(8, 分块数量)   
        float _464 = max(                                   // 单位块的距离
                            _459 / max(                     
                                        8.0f,               // 最小的块数量
                                        round(              // 分块数量 = _459 / 125.0  块距离
                                            _459 / lerp(
                                                        _77_m26.w,                      //对应的云层进行Intersect 距离分块的最小块距离
                                                        _77_m26.w * 0.5f, 
                                                        clamp(                          //abs ViewDirZ norli
                                                              (_370 - 0.5f) * 2.0f, 
                                                                0.0f, 
                                                                1.0f)
                                                        )
                                            )
                                    ), 
                            
                            9.9999999747524270787835121154785e-07f); //0.000001


        //_361 噪声

        float _466 = _77_m50.z + (_361 * _464);         //基础的Ray Intersect 距离  + 噪声 * 单位块的距离， 开始的RayIntersect distance

        float4 _468;
        float _481;
        float _483;
        float _489;

        _468 = 0.0f.xxxx;
        _481 = _77_m50.z;               // 初始RayTracing Distance
        _483 = 0.0f;
        _489 = 1.0f;                    // 初始的Ray Transmittance 值

        int _486;
        float4 _469;
        float _472;
        bool _474;
        float _476;
        int _478;
        int _480;
        float _482;
        float _484;
        float _488;
        float _490;
        float _471 = _77_m40.w;         //0.35
        bool _473 = false;

        float _475 = _464;              //单位块的距离

        int _477 = 4;
        int _479 = 0;
        int _485 = 0;

        float _487 = _466;              //开始的栈Frame 对应的效果

        [loop]
        for (; 
            ( 
                (_489 > _77_m37.z) &&   //对应的Transmittance 衰减值
                (_487 <= _424)) &&      //_487 对应的当前的Intersect RayDistance， _424对应的大气的长度
                (_485 < 1000);          //Loop Index
            
                _468 = _469,            //_468 初始值 为 [0,0,0,0]
                _471 = _472,            //_472 如果是cloudDensity 》 的部分，最终将修正 一个_77_m40.w  的常量值
                _473 = _474,            //_474 Section中是否存在浓度够
                _475 = _476,            //_476 新的单位块的距离
                _477 = _478,            //_478 记录剩余的RayTracing Section Index
                _479 = _480,            //_480 记录当前的RayTracing Section index
                _481 = _482,            //_481 最终的记录的深度，  
                _483 = _484, 
                _485 = _486,            //_486 新的index  
                _487 = _488,            //_488 新的RayTracing Distance
                _489 = _490)            //_490 新的Transmittance
        {
            do
            {
                float3 _502 = _324 * _487;      //TranslatedViewDir *  RayDistance
                float3 _503 = _378 + _502;      //ViewOrigin + TranslatedViewDir * RayDistance   == CheckPointWorldPosition

                float _511 = clamp(
                                    (
                                        (length(_503 - _280) - 318000.0f) - _77_m27.x       // CheckPointWorldPosition - SphereCenter - 318000,  ModifyCheckPointHeight  - _77_m27.x
                                    ) * 0.00076923076994717121124267578125f,                // * 1/1300
                                    0.0f, 
                                    1.0f
                                );
                           // = ViewHeight * Scale;

                float3 _517 = float3(_77_m29.xy, 0.0f) * _511;
                float3 _518 = _503 + _517;      //CheckPointWorldPosition + _511 * Dir

                //这个部分的代码需要解决的核心问题， 就是针对每一个Checkpoint WorldPosition, 如何确定对应的云图所Check 的UV映射关系， 暂时看来，通过修正之后的高度，高度确定一个UV偏移的距离


                float4 _528 = _82.SampleLevel(_7, (_518.xy * _77_m28.w) + 0.5f.xx, 0.0f);   //对应的云图所对应的 WorldPosition 以及采样UV 修正
                float _531 = max(0.0f, _511 - _528.z);                                      //采样点云层的高度修正值  Lut 高度修正的系数

                                                                                            //float2 c = SampleCloudMap(rap.p)   _528
                                                                                            //c.xy = _528.xy
                float _557;
                float _558;

                [branch]
                if (true && (_531 > 0.0f))                                                  //ViewHeight *Scale - 修正  》 0
                {
                                                                                            //基于高度的形状修正， 从一张atlas 通过 weather parameters 来生成
                    float4 _540 = _81.SampleLevel(_83, float2(0.0f, _531), 0.0f);           //高度修正之后的对应的贴图  利用经过修正之后的高度采样一张贴图，或者了两个高度上的衰减值
                                                                                            //_540 cloudLut()
                                                                                            //_531 cloudLutaltitude

                                                                                            //_540 cloud Z controls the softness of the noise

                                                                                            //_77_m56.xz = g_CloudShape.xz
                                                                                            //_77_m56.yw = g_CloudShape.yw

                    float2 _543 = 1.0f.xx - _540.xy;                                        //_543 = 1.0f.xx - _540.xy
                    _557 = _540.w;                                                          //_557 cloudLut.w   对应的云层高度风场的强度。
                    _558 = min(
                                1.0f, 
                                dot(
                                    float2(1.0f, _540.z), 
                                    smoothstep(
                                                _77_m56.xz + _543, 
                                                _77_m56.yw + _543, 
                                                _528.xy                                      //对应云图的RG 通道
                                            ).xy                                             
                                    )                                                        //                          min, max, c.xy
                                );                                                           //_558 density.xy = smoothstep(g_cloudShape.xz + 1.0 - cloudLut.xy, g_CloudShape + 1.0 - cloudLut.xy, c.xy);
                                                                                             //                = smoothstep(g_cloudShape.xz + cloudLut.xy + 1.0 - 2*cloudLUt.xy, ...)
                                                                                             //                = BasicDensity + 1.0 - 2 *cloudLut.xy
                                                                                             //                =
                }                                                                            //_558 density = min(1,0f,  density.x + cloudLut.z * density.y);
                                                                                             //             = BasicDensity.x + 1.0 - 2*cloudLut.x + cloudLUt.z * (BasicDensity.y + 1.0 - 2 * CloudLut.y)
                                                                                             //             =
                                                                                           

                else                                                                         //在云层下
                {
                    _557 = 0.0f;
                    _558 = 0.0f;
                }

                //_558 对应的SamplePoint 所对应 cloud Density
                //_557 对应的SamplePoint 对应的 cloudLut.w

                bool _569 = _558 >                              //如果当前采样获得的Cloud Density 已经足够大的化
                                (_77_m12.y *        //0.20
                                    min(            //最大值为1， 依赖于剩余路径长度
                                            clamp(
                                                    (_424 - _487) * 9.9999997473787516355514526367188e-05f,         //剩余Raydistance  /10000
                                                    0.0f, 
                                                    1.0f
                                                ), 
                                                
                                            1.0f - clamp(
                                                            _370 * 1.33333337306976318359375f,                      //abs(ViewDirZ)
                                                            0.0f, 
                                                            1.0f)
                                        )
                                );


                if (
                    (
                        (float(_569) > 0.0f) && 
                        (_479 < _477)                       //CurrentRayTracing Section index < 剩余的RayTracing Section index 初始值为4， 对应的剩余Distance/maxDistance * 4 拆分为
                    ) && true)                              //满足当前条件的话，当前Sample点 完结
                {
                    float _583 = lerp(
                                        1.0f, 
                                        _77_m40.w,          //RayTracing 距离衰减参数基础 0.35
                                        clamp((_489 - _77_m12.w) / (1.0f - _77_m12.w), 0.0f, 1.0f));     //77_m12.w = -1
                    
                    float _586 = _475 * _583;               //新的RayTracing 距离将在现在的基础上进行衰减。

                    _469 = _468;
                    _472 = _583;                            //距离衰减系数
                    _474 = true;                            //当前存在cloud 浓度够的Sample点

                    _476 = _586;                            //新的单位块的长度
                    _478 = _477;
                    _480 = _479 + 1;
                    _482 = _481;
                    _484 = _483;

                    _488 = max(                              //新的RayTracing长度
                                    _77_m50.z + (_586 * _361),      //基础rayTracing Distance + 噪声 * 新的距离
                                    _487 - (_475 * (1.0f - _583))   //当前RayTracing Distance - （当前块长度* 衰减掉的部分）
                            );          

                    _490 = _489;
                    break;
                }


                //Section Fog 对应的低高度地区，相关的雾效果浓度 或者噪声
                float3 _597 = (_503 * asfloat(_29.Load3(380))) + asfloat(_29.Load3(392));       //CheckPointWorldPosition 相关的修正
                float _598 = _503.z;
                float _632;
                if (true && (_598 < asfloat(_29.Load(376))))                                    //如果对应的的CheckPointWorldPosition 小于某一个特定的值
                {
                    float3 _612 = (_503 * _77_m20.xyz) + _77_m21.xyz;
                    float _613 = _612.z;
                    float4 _621 = _79.SampleLevel(_74, float3(_597.xy, _613).xy, 0.0f);         //对应的雾效果  的相关的
                    float _629 = 1.0f - min(1.0f, abs((_613 - _621.x) / _621.y));               
                    _632 = _621.z * (_629 * _629);                                              //对应的雾效果浓度
                }
                else
                {
                    _632 = 0.0f;
                }



                float _715;
                //2x 2D displacement samples   _80
                //At xy and xz coordinate of sample position

                //1x 3D Perlin/Worley noise samples
                //Displaced via 2D noise + wind offset
                if (_558 > 0.0f)                                            //对应的云的密度
                {
                    float _665;
                    do
                    {
                        if (_558 == 0.0f)
                        {
                            _665 = 0.0f;
                            break;
                        }
                        //cloudLut Sampe Height _531
                                                                                                            //density = rescale(noise, CloudLut.z, density)
                                                                                             //                       = saturate( (density - noise) / (density - cloudLut.z) )
                        float2 _657 = (_77_m52.yw * _531) + _77_m52.xz;                                     //RescaleVmin, RescaleVmax
                        float _658 = _657.x;
                        _665 = _558 * clamp(
                                                (
                                                    _78.SampleLevel( 
                                                                        _7, 
                                                                        (_503 + _77_m39.xyz) * _77_m37.y, 0.0f              //3DNoiseSample - 658
                                                                    ).x - _658
                                                ) / (_657.y - _658),                                                        //(3DNoiseSample - vmin) / (vmax - vmin)
                                                
                                                0.0f, 
                                                1.0f
                                            );

                        //_665 = _558 (cloudDensity)  * rescale( )

                        break;

                    } while(false);

                    float3 _672 = (_503 + _77_m38.xyz) * _77_m49.w;                 //DisplaceNoise WorldPosition


                    float _704 = 1.0f - _78.SampleLevel(
                                                            _7,  //SamplerState

                                                            ((_503 + (_77_m38.xyz * 1.5f)) * _77_m37.x)                         //Displaced via wind offset
                                                            + 
                                                            (
                                                                (
                                                                    (
                                                                        (
                                                                            _80.SampleLevel(_7, _672.xy, 0.0f).xyz * 2.0f       //via 2D noise
                                                                        ) - 1.0f.xxx
                                                                    ) + 
                                                                    (
                                                                        (
                                                                            _80.SampleLevel(_7, _672.xz, 0.0f).xyz * 2.0f
                                                                        )  - 1.0f.xxx
                                                                    )
                                                                ) * 
                                                                    (_77_m54.x + (_77_m54.y * _557))                            //2D noise Power Offset
                                                            ), 0.0f
                                                        ).x;                                                                    //_557 对应的Clound云层所在的 风场强度

                    _715 = clamp(
                                    (_665 - _704) / 
                                    ((   (_77_m53.y * _557) + _77_m53.x) - _704), 
                                    
                                    0.0f, 
                                    1.0f);
                }
                else
                {
                    _715 = _558;                                                                                                 //
                }

                //_715 经过3D Noise 以及 2x2D Displacement & Wind 修正之后的 cloudDenisy


                float _723 = 1.0f - clamp((_598 - _77_m40.x) * _77_m40.y, 0.0f, 1.0f);                                      //CheckPointWorldPositionZ 相关的修正
                float _744;
                [branch]
                if (_77_m44.x > 0.0f)
                {
                    _744 = (1.0f - clamp(_531 * 10.0f, 0.0f, 1.0f)) * (_77_m44.x * clamp(_528.y - _77_m44.y, 0.0f, 1.0f));                  //采样点云层高度修正？
                }
                else
                {
                    _744 = 0.0f;
                }


                float _748 = _715 + (                                                                       
                                        (
                                            (_632 +                                                 //雾效果浓度
                                                (
                                                    ((_723 * _723) * _723) * _77_m40.z              //Function(Z)^3 * Modifiler
                                                )
                                            ) + _744                                                //_744 0
                                        ) * _77_m31[0].w                                            //雾效果的流动。
                                    );

                //_748 +雾 效果扰动的 cloud Density

                float4 _760 = mul(_73_m13, float4(_502 + _517, 1.0f));
                float _799;
                do
                {
                    float2 _763 = _760.xy;
                    float2 _766 = abs((_763 * 2.0f) - 1.0f.xx);
                    if (any(bool2(_766.x > 1.0f.xx.x, _766.y > 1.0f.xx.y)))
                    {
                        _799 = asfloat(_29.Load(1792));
                        break;
                    }
                    _799 = lerp(
                                    clamp(
                                        clamp(
                                                (
                                                    clamp(
                                                        _68.SampleLevel(_6, _763, 1.0f).x / exp(asfloat(_29.Load(1760)) * _760.z),      //对应的实际的云图？
                                                        0.0f, 
                                                        1.0f
                                                        ) * (1.0f + _77_m44.z)
                                                ) - _77_m44.z, 
                                                
                                                0.0f, 
                                                1.0f
                                            ),

                                            0.0f, 
                                            1.0f
                                        ), 
                                        
                                        asfloat(_29.Load(1792)), 
                                        
                                        clamp(
                                                (max(_766.x, _766.y) - 0.89999997615814208984375f) * 10.0f, 
                                                0.0f, 
                                                1.0f
                                            )
                                );
                    break;
                } while(false);


                float4 _806 = _75.SampleLevel(_74, _597.xy, 0.0f);  //噪声
                float _807 = _806.y;
                float _833 = 1.0f - (sqrt(clamp((_502.z * _73_m0[3].x) + _73_m0[3].y, 0.0f, 1.0f)) * _77_m42.z);
                float _834 = _833 * _833;
                float _835 = (
                                max(_77_m43.y, _799 * _799) * 
                                    min(
                                        1.0f, 
                                        clamp(
                                                ((_597.z - _806.x) + (_807 * 0.25f)) / (_807 * 0.5f), 
                                                0.0f, 
                                                1.0f
                                            ) + _77_m46.w
                                        )
                            ) * _834;

                float4 _1401;




                if (_748 > 0.0f)
                {
                    bool _852 = _715 > 0.0f;
                    float2 _1379;
                    if (_852)
                    {
                        float3 _865 = _518 + (_77_m28.xyz * 0.25f);
                        float4 _870 = _82.SampleLevel(_7, (_865.xy * _77_m28.w) + 0.5f.xx, 0.0f);
                        float _879 = max(0.0f, clamp(((length(_865 - _280) - 318000.0f) - _77_m27.x) * 0.00076923076994717121124267578125f, 0.0f, 1.0f) - _870.z);
                        float4 _884 = _81.SampleLevel(_83, float2(0.0f, _879), 0.0f);
                        float2 _887 = 1.0f.xx - _884.xy;
                        float _900 = min(1.0f, dot(float2(1.0f, _884.z), smoothstep(_77_m56.xz + _887, _77_m56.yw + _887, _870.xy).xy));
                        float _930;
                        do
                        {
                            if (_900 == 0.0f)
                            {
                                _930 = 0.0f;
                                break;
                            }
                            float2 _922 = (_77_m52.yw * _879) + _77_m52.xz;
                            float _923 = _922.x;
                            _930 = _900 * clamp((_78.SampleLevel(_7, (_865 + _77_m39.xyz) * _77_m37.y, 0.0f).x - _923) / (_922.y - _923), 0.0f, 1.0f);
                            break;
                        } while(false);
                        float3 _940 = _77_m38.xyz * 1.5f;
                        float _949 = 1.0f - _78.SampleLevel(_7, (_865 + _940) * _77_m37.x, 0.0f).x;
                        float3 _966 = _518 + (_77_m28.xyz * 0.5f);
                        float4 _971 = _82.SampleLevel(_7, (_966.xy * _77_m28.w) + 0.5f.xx, 0.0f);
                        float _980 = max(0.0f, clamp(((length(_966 - _280) - 318000.0f) - _77_m27.x) * 0.00076923076994717121124267578125f, 0.0f, 1.0f) - _971.z);
                        float4 _983 = _81.SampleLevel(_83, float2(0.0f, _980), 0.0f);
                        float2 _986 = 1.0f.xx - _983.xy;
                        float _995 = min(1.0f, dot(float2(1.0f, _983.z), smoothstep(_77_m56.xz + _986, _77_m56.yw + _986, _971.xy).xy));
                        float _1024;
                        do
                        {
                            if (_995 == 0.0f)
                            {
                                _1024 = 0.0f;
                                break;
                            }
                            float2 _1016 = (_77_m52.yw * _980) + _77_m52.xz;
                            float _1017 = _1016.x;
                            _1024 = _995 * clamp((_78.SampleLevel(_7, (_966 + _77_m39.xyz) * _77_m37.y, 0.0f).x - _1017) / (_1016.y - _1017), 0.0f, 1.0f);
                            break;
                        } while(false);
                        float _1035 = 1.0f - _78.SampleLevel(_7, (_966 + _940) * _77_m37.x, 0.0f).x;
                        float3 _1048 = _518 + (_77_m28.xyz * 1.0f);
                        float4 _1053 = _82.SampleLevel(_7, (_1048.xy * _77_m28.w) + 0.5f.xx, 0.0f);
                        float _1062 = max(0.0f, clamp(((length(_1048 - _280) - 318000.0f) - _77_m27.x) * 0.00076923076994717121124267578125f, 0.0f, 1.0f) - _1053.z);
                        float4 _1065 = _81.SampleLevel(_83, float2(0.0f, _1062), 0.0f);
                        float2 _1068 = 1.0f.xx - _1065.xy;
                        float _1077 = min(1.0f, dot(float2(1.0f, _1065.z), smoothstep(_77_m56.xz + _1068, _77_m56.yw + _1068, _1053.xy).xy));
                        float _1106;
                        do
                        {
                            if (_1077 == 0.0f)
                            {
                                _1106 = 0.0f;
                                break;
                            }
                            float2 _1098 = (_77_m52.yw * _1062) + _77_m52.xz;
                            float _1099 = _1098.x;
                            _1106 = _1077 * clamp((_78.SampleLevel(_7, (_1048 + _77_m39.xyz) * _77_m37.y, 0.0f).x - _1099) / (_1098.y - _1099), 0.0f, 1.0f);
                            break;
                        } while(false);
                        float _1118 = 1.0f - _78.SampleLevel(_7, (_1048 + _940) * _77_m37.x, 0.0f).x;
                        float _1124 = clamp((_1106 - _1118) / (((_77_m53.y * _1065.w) + _77_m53.x) - _1118), 0.0f, 1.0f);
                        float _1130 = (_715 + _1106) + _1124;
                        float3 _1132 = _518 + (_77_m28.xyz * 2.0f);
                        float4 _1137 = _82.SampleLevel(_7, (_1132.xy * _77_m28.w) + 0.5f.xx, 0.0f);
                        float _1146 = max(0.0f, clamp(((length(_1132 - _280) - 318000.0f) - _77_m27.x) * 0.00076923076994717121124267578125f, 0.0f, 1.0f) - _1137.z);
                        float4 _1149 = _81.SampleLevel(_83, float2(0.0f, _1146), 0.0f);
                        float2 _1152 = 1.0f.xx - _1149.xy;
                        float _1161 = min(1.0f, dot(float2(1.0f, _1149.z), smoothstep(_77_m56.xz + _1152, _77_m56.yw + _1152, _1137.xy).xy));
                        float _1190;
                        do
                        {
                            if (_1161 == 0.0f)
                            {
                                _1190 = 0.0f;
                                break;
                            }
                            float2 _1182 = (_77_m52.yw * _1146) + _77_m52.xz;
                            float _1183 = _1182.x;
                            _1190 = _1161 * clamp((_78.SampleLevel(_7, (_1132 + _77_m39.xyz) * _77_m37.y, 0.0f).x - _1183) / (_1182.y - _1183), 0.0f, 1.0f);
                            break;
                        } while(false);
                        float _1201 = 1.0f - _78.SampleLevel(_7, (_1132 + _940) * _77_m37.x, 0.0f).x;
                        float3 _1214 = _518 + (_77_m28.xyz * 4.0f);
                        float4 _1219 = _82.SampleLevel(_7, (_1214.xy * _77_m28.w) + 0.5f.xx, 0.0f);
                        float _1228 = max(0.0f, clamp(((length(_1214 - _280) - 318000.0f) - _77_m27.x) * 0.00076923076994717121124267578125f, 0.0f, 1.0f) - _1219.z);
                        float4 _1231 = _81.SampleLevel(_83, float2(0.0f, _1228), 0.0f);
                        float2 _1234 = 1.0f.xx - _1231.xy;
                        float _1243 = min(1.0f, dot(float2(1.0f, _1231.z), smoothstep(_77_m56.xz + _1234, _77_m56.yw + _1234, _1219.xy).xy));
                        float _1272;
                        do
                        {
                            if (_1243 == 0.0f)
                            {
                                _1272 = 0.0f;
                                break;
                            }
                            float2 _1264 = (_77_m52.yw * _1228) + _77_m52.xz;
                            float _1265 = _1264.x;
                            _1272 = _1243 * clamp((_78.SampleLevel(_7, (_1214 + _77_m39.xyz) * _77_m37.y, 0.0f).x - _1265) / (_1264.y - _1265), 0.0f, 1.0f);
                            break;
                        } while(false);
                        float _1283 = 1.0f - _78.SampleLevel(_7, (_1214 + _940) * _77_m37.x, 0.0f).x;
                        float3 _1302 = _518 + float3(0.0f, 0.0f, 100.0f);
                        float4 _1307 = _82.SampleLevel(_7, (_1302.xy * _77_m28.w) + 0.5f.xx, 0.0f);
                        float _1316 = max(0.0f, clamp(((length(_1302 - _280) - 318000.0f) - _77_m27.x) * 0.00076923076994717121124267578125f, 0.0f, 1.0f) - _1307.z);
                        float4 _1319 = _81.SampleLevel(_83, float2(0.0f, _1316), 0.0f);
                        float2 _1322 = 1.0f.xx - _1319.xy;
                        float _1331 = min(1.0f, dot(float2(1.0f, _1319.z), smoothstep(_77_m56.xz + _1322, _77_m56.yw + _1322, _1307.xy).xy));
                        float _1360;
                        do
                        {
                            if (_1331 == 0.0f)
                            {
                                _1360 = 0.0f;
                                break;
                            }
                            float2 _1352 = (_77_m52.yw * _1316) + _77_m52.xz;
                            float _1353 = _1352.x;
                            _1360 = _1331 * clamp((_78.SampleLevel(_7, (_1302 + _77_m39.xyz) * _77_m37.y, 0.0f).x - _1353) / (_1352.y - _1353), 0.0f, 1.0f);
                            break;
                        } while(false);
                        _1379 = float2(exp((-((_1130 - (_715 * _77_m55.w)) + (clamp((_1360 - 0.1500000059604644775390625f) / (((_77_m53.y * _1319.w) + _77_m53.x) - 0.1500000059604644775390625f), 0.0f, 1.0f) * 3.0f))) * _77_m26.x), (((((((((exp(((-_930) * _77_m26.y) * 0.100000001490116119384765625f) * exp(((-clamp((_930 - _949) / (((_77_m53.y * _884.w) + _77_m53.x) - _949), 0.0f, 1.0f)) * _77_m26.y) * 0.100000001490116119384765625f)) * exp(((-_1024) * _77_m26.y) * 0.20000000298023223876953125f)) * exp(((-clamp((_1024 - _1035) / (((_77_m53.y * _983.w) + _77_m53.x) - _1035), 0.0f, 1.0f)) * _77_m26.y) * 0.20000000298023223876953125f)) * exp(((-_1106) * _77_m26.y) * 0.4000000059604644775390625f)) * exp(((-_1124) * _77_m26.y) * 0.4000000059604644775390625f)) * exp(((-_1190) * _77_m26.y) * 0.800000011920928955078125f)) * exp(((-clamp((_1190 - _1201) / (((_77_m53.y * _1149.w) + _77_m53.x) - _1201), 0.0f, 1.0f)) * _77_m26.y) * 0.800000011920928955078125f)) * exp(((-_1272) * _77_m26.y) * 1.60000002384185791015625f)) * exp(((-clamp((_1272 - _1283) / (((_77_m53.y * _1231.w) + _77_m53.x) - _1283), 0.0f, 1.0f)) * _77_m26.y) * 1.60000002384185791015625f)) * (1.0f - exp((-_1130) * _77_m26.z)));
                    }
                    else
                    {
                        _1379 = exp((-_748) * _77_m43.z).xx;
                    }
                    float4 _1391 = _273;
                    _1391.x = _1379.x * clamp(_834 * _77_m33[1].w, 0.0f, 1.0f);
                    float4 _1392 = _1391;
                    _1392.y = (_1379.y * _835) * (max(_445, clamp(_748 * _77_m48.w, 0.0f, 1.0f) * _77_m48.z) + (_458 * lerp(_748, 1.0f, _77_m45.w)));
                    float4 _1393 = _1392;
                    _1393.z = _1379.y * (_852 ? _834 : _835);
                    float4 _1400 = _1393;
                    _1400.w = (1.0f - (_715 / _748)) * clamp((_487 - 300.0f) * 0.004999999888241291046142578125f, 0.0f, 1.0f);
                    _1401 = _1400;
                }
                else
                {
                    _1401 = 0.0f.xxxx;
                }

                float4 _1402 = _1401 * _748;
                float _1405 = exp((-_748) * _475);                  //()   //当前块的Transmittance衰减
                float _1413 = _489 * _1405;                         //剩余的Transmittance * 当前块的衰减

                float _1414 = _1413 * _1413;                        //包含当前块Transmittance ^2
                int _1431;


                if (true && (_479 == 0))                                    //如果当前RayTracing Section index 为0
                {
                    _1431 = int(4.0f * (1.0f - (_487 / _77_m37.w)));        //_1431 = int( 4.0 * ( 1 - ( 当前RayTracingDistance / MaxRayTracingDistance)))  0, 1, 2, 3  剩余的Raytracing Section
                }
                else                                                        //如果当前的RayTracing Section index 不为0
                {
                    _1431 = _477;                                           //_1431 = _477      //最大的RayTracing Section Index = CurrentRayTracingSection Index
                }




                bool _1436 = (
                                (!_569) &&                              //如果当前雾不够浓         
                                (_479 > 0)                              //当前块的RayTracing Section Index 》 0
                            ) && 
                                (!_473);                                //之前不存在雾浓度，在这一个Ray Tracing Section


                float _1445;
                float _1446;


                if (_1436)
                {
                    float _1442 = _475 * pow(1.0f / _471, float(_479));
                    _1445 = _487 + (_361 * _1442);
                    _1446 = _1442;
                }
                else
                {
                    _1445 = _487;
                    _1446 = _475;                                       //单位块的距离
                }


                int _1447 = _1436 ? 0 : _479;

                bool _1450 = (_569 &&                                                //_569当前雾效果的浓度已经足够大的化
                                (_1447 > 0)) ? false : _473;

                                // _1450 = ( _569 && (_1447 > 0)) ? false : _473
                                //       = reset to false
                                //       = 473                   

                float _1463;


                //#Section  新的单位块的距离
                if (true && (!_1450))
                {
                    _1463 = _1446 * (1.0f + (_77_m12.z * (1.0f - clamp(_370 * 2.0f, 0.0f, 1.0f))));
                }
                else
                {
                    _1463 = _1446;
                }
                //#Section 单位块的距离End

                _469 = _468 + (((_1402 - (_1402 * _1405)) / max(_748, 9.9999999747524270787835121154785e-07f).xxxx) * _489);

                _472 = _471;


                _474 = _1450;           
    
                //New block Distance
                _476 = _1463;

                //
                _478 = _1431;


                          
                _480 = _1447;           //480 = 0    重置为0            1436 ? 0 : _479;
                                        //480 = 0   ( _479 > 0 ) && ( !569 ) && ( !_473 )

                                        //480 = 479  使用之前的状态 



                _482 = lerp(
                                _481,           //前一Loop RayTracing Distance 
                                _487,           //当前Loop RayTracing Distance
                                _1414 * _1414   //包含当前块Transmittance^4
                                );              //新的记录的深度



                _484 = _483 + (
                                    (_835 * _475) * 
                                                    clamp( (_1413 - 0.20000000298023223876953125f) * 1.25f, 0.0f, 1.0f) 
                                                    //包含当前块的Transmittance -0.2 ）* 1.25
                             );


                _488 = _1445 + _1463;           //新的RayTracing Distance

                _490 = _1413;                   //当前剩余的Transmittance


                break;
            } while(false);
            _486 = _485 + 1;
        }
        //Loop End

        float _1507 = acos(-_434);
        float3 _1511 = ((_1507 - 0.698131740093231201171875f) * 28.6479053497314453125f).xxx - float3(0.75f, 0.5f, 0.25f);
        float3 _1519 = ((_1507 - 0.89011800289154052734375f) * (-19.09857177734375f)).xxx - float3(0.75f, 0.5f, 0.25f);
        float3 _1530 = (((asfloat(_61.Load4(208)).xyz * _77_m27.y) + asfloat(_61.Load4(224)).xyz) * _77_m45.xyz) * _468.y;
        float3 _1533 = ((_77_m46.xyz * asfloat(_61.Load4(192)).xyz) * 1.0f) * _468.z;
        float3 _1540 = ((((((asfloat(_61.Load4(96)).xyz + _77_m47.xyz) * _77_m22.w) * (((_429.z * 0.5f) + 1.0f) * 0.666666686534881591796875f)) * _468.x) + _1530) + _1533).xyz + (((_1530 + _1533) * _468.w) * ((max(1.0f.xxx - ((_1511 * 10.0f) * _1511), 0.0f.xxx) + (max(1.0f.xxx - ((_1519 * 10.0f) * _1519), 0.0f.xxx) * 0.333000004291534423828125f)) * _77_m59.y));
        float4 _1542 = float4(_1540.x, _1540.y, _1540.z, float4(0.0f, 0.0f, 0.0f, 1.0f).w);
        _1542.w = clamp((_489 - _77_m37.z) / (1.0f - _77_m37.z), 0.0f, 1.0f);
        _1543 = _1542;

        _1544 = _481;   //_481 记录最终的云层的深度

        _1545 = _483;
    }
    else
    {
        _1543 = float4(0.0f, 0.0f, 0.0f, 1.0f);
        _1544 = 0.00999999977648258209228515625f;
        _1545 = 0.0f;
    }

    //
    //




    float3 _1547 = normalize(_324);
    float _1562 = _306.x;
    float _1570 = _1545 + (_88.SampleLevel(_5, float3(_1562, _306.y, log2((clamp(min(_77_m50.z, _329) / _77_m50.y, 0.0f, 1.0f) * asfloat(_29.Load(1800))) + 1.0f) * asfloat(_29.Load(1796))), 0.0f).x * min(_329, _77_m50.z));
    float4 _1630;


    //如果是天空
    if (true && _325)
    {
        float _1600 = _77_m63.z * _77_m63.z;
        float _1620 = _77_m53.z * pow(1.0f - max(0.0f, _1547.z), _77_m53.w);
        float3 _1625 = _1543.xyz + (((((((asfloat(_61.Load4(320)).xyz * _77_m64.w) + asfloat(_61.Load4(336)).xyz) * _77_m45.xyz) * max(0.100000001490116119384765625f, 0.079577468335628509521484375f * ((1.0f - _1600) / pow((1.0f + _1600) - ((2.0f * _77_m63.z) * dot(_1547, _77_m49.xyz)), 1.5f)))) + (asfloat(_61.Load4(96)).xyz * _77_m22.w)) * _1620) * _1543.w);
        float4 _1629 = float4(_1625.x, _1625.y, _1625.z, _1543.w);
        _1629.w = _1543.w * (1.0f - _1620);
        _1630 = _1629;
    }
    else
    {
        _1630 = _1543;
    }





    float _1632 = clamp(_1570 / _1544, 0.0f, 1.0f);
    float3 _1633 = _1547 * _1544;
    float3 _1634 = normalize(_1633);
    float _1635 = length(_1633);
    float3 _1640 = float3(_1562, _306.y, clamp(_1635 * asfloat(_59.Load(1356)), 0.0f, 1.0f));
    float _1647 = clamp((_1635 - asfloat(_59.Load(1384))) * asfloat(_59.Load(1360)), 0.0f, 1.0f);
    float4 _1656 = _65.SampleLevel(_5, _1640, 0.0f);
    float4 _1659 = _66.SampleLevel(_5, _1640, 0.0f);
    float4 _1662 = _67.SampleLevel(_5, _1640, 0.0f);
    float _1663 = _1656.x;
    float _1664 = _1659.x;
    float _1665 = _1662.x;
    float _1666 = _1656.y;
    float _1667 = _1659.y;
    float _1668 = _1662.y;
    float _1669 = _1656.z;
    float _1670 = _1659.z;
    float _1671 = _1662.z;
    float _1672 = _1656.w;
    float _1673 = _1659.w;
    float _1674 = _1662.w;
    float _1716 = lerp(min(0.5f, asfloat(_29.Load(732))), asfloat(_29.Load(732)), clamp(_1635 * 0.008333333767950534820556640625f, 0.0f, 1.0f));
    float _1720 = dot(_1634, asfloat(_29.Load4(1764)).xyz);
    float _1722 = 1.0f + (_1720 * _1720);
    float _1724 = _1716 * _1716;
    float _1729 = (3.0f * (1.0f - _1724)) / (2.0f * (2.0f + _1724));
    float _1730 = 1.0f + _1724;
    float _1731 = 2.0f * _1716;
    float _1742 = dot(_1634, asfloat(_29.Load4(1780)).xyz);
    float _1744 = 1.0f + (_1742 * _1742);
    float3 _1756 = (((float3((_1663 + _1664) - _1665, _1663 + _1665, (_1663 - _1664) - _1665) * asfloat(_59.Load3(1428))) * (0.75f * _1722)) + ((float3((_1669 + _1670) - _1671, _1669 + _1671, (_1669 - _1670) - _1671) * asfloat(_59.Load3(1452))) * (0.75f * _1744))) * _1647;
    float _1777 = 1.0f - _1630.w;
    float3 _1795 = (_1630.xyz * lerp(1.0f.xxx, lerp(1.0f.xxx, _64.SampleLevel(_5, _1640, 0.0f).xyz, _1647.xxx), pow(_1777 * _77_m42.y, _77_m42.x).xxx)).xyz + (clamp(lerp(((normalize(max(asfloat(_61.Load4(96)).xyz, 9.9999997473787516355514526367188e-05f.xxx)) * asfloat(_29.Load(1748))) * clamp((_1635 - 160.0f) * 0.0500000007450580596923828125f, 0.0f, 1.0f)) * _1756, _1756, max(asfloat(_29.Load(1744)), _1632).xxx) + (((((float3((_1666 + _1667) - _1668, _1666 + _1668, (_1666 - _1667) - _1668) * asfloat(_59.Load3(1416))) * (_1729 * (_1722 / pow(_1730 - (_1731 * _1720), 1.5f)))) + ((float3((_1672 + _1673) - _1674, _1672 + _1674, (_1672 - _1673) - _1674) * asfloat(_59.Load3(1440))) * (_1729 * (_1744 / pow(_1730 - (_1731 * _1742), 1.5f))))) * _1647) * _1632), 0.0f.xxx, asfloat(_59.Load(1380)).xxx) * _1777);
    float4 _1932;
    if (!_325)
    {
        float _1802 = clamp(_1570 / max(0.001000000047497451305389404296875f, _329), 0.0f, 1.0f);
        float3 _1803 = _1547 * _329;
        float3 _1804 = normalize(_1803);
        float _1805 = length(_1803);
        float3 _1809 = float3(_1562, _306.y, clamp(_1805 * asfloat(_59.Load(1356)), 0.0f, 1.0f));
        float _1814 = clamp((_1805 - asfloat(_59.Load(1384))) * asfloat(_59.Load(1360)), 0.0f, 1.0f);
        float4 _1816 = _65.SampleLevel(_5, _1809, 0.0f);
        float4 _1818 = _66.SampleLevel(_5, _1809, 0.0f);
        float4 _1820 = _67.SampleLevel(_5, _1809, 0.0f);
        float _1821 = _1816.x;
        float _1822 = _1818.x;
        float _1823 = _1820.x;
        float _1824 = _1816.y;
        float _1825 = _1818.y;
        float _1826 = _1820.y;
        float _1827 = _1816.z;
        float _1828 = _1818.z;
        float _1829 = _1820.z;
        float _1830 = _1816.w;
        float _1831 = _1818.w;
        float _1832 = _1820.w;
        float _1869 = lerp(min(0.5f, asfloat(_29.Load(732))), asfloat(_29.Load(732)), clamp(_1805 * 0.008333333767950534820556640625f, 0.0f, 1.0f));
        float _1872 = dot(_1804, asfloat(_29.Load4(1764)).xyz);
        float _1874 = 1.0f + (_1872 * _1872);
        float _1876 = _1869 * _1869;
        float _1881 = (3.0f * (1.0f - _1876)) / (2.0f * (2.0f + _1876));
        float _1882 = 1.0f + _1876;
        float _1883 = 2.0f * _1869;
        float _1893 = dot(_1804, asfloat(_29.Load4(1780)).xyz);
        float _1895 = 1.0f + (_1893 * _1893);
        float3 _1907 = (((float3((_1821 + _1822) - _1823, _1821 + _1823, (_1821 - _1822) - _1823) * asfloat(_59.Load3(1428))) * (0.75f * _1874)) + ((float3((_1827 + _1828) - _1829, _1827 + _1829, (_1827 - _1828) - _1829) * asfloat(_59.Load3(1452))) * (0.75f * _1895))) * _1814;
        float3 _1930 = _1795.xyz + (clamp(lerp(((normalize(max(asfloat(_61.Load4(96)).xyz, 9.9999997473787516355514526367188e-05f.xxx)) * asfloat(_29.Load(1748))) * clamp((_1805 - 160.0f) * 0.0500000007450580596923828125f, 0.0f, 1.0f)) * _1907, _1907, max(asfloat(_29.Load(1744)), _1802).xxx) + (((((float3((_1824 + _1825) - _1826, _1824 + _1826, (_1824 - _1825) - _1826) * asfloat(_59.Load3(1416))) * (_1881 * (_1874 / pow(_1882 - (_1883 * _1872), 1.5f)))) + ((float3((_1830 + _1831) - _1832, _1830 + _1832, (_1830 - _1831) - _1832) * asfloat(_59.Load3(1440))) * (_1881 * (_1895 / pow(_1882 - (_1883 * _1893), 1.5f))))) * _1814) * _1802), 0.0f.xxx, asfloat(_59.Load(1380)).xxx) * _1630.w);
        _1932 = float4(_1930.x, _1930.y, _1930.z, _1630.w);
    }
    else
    {
        _1932 = float4(_1795.x, _1795.y, _1795.z, _1630.w);
    }

    _85[gl_GlobalInvocationID.xy] = float4(_1932.xyz * _71.Load(int3(int2(0, 0), 0)).y, _1932.w);    //对应的颜色
    _87[gl_GlobalInvocationID.xy] = (_1544 > _77_m50.z) ? min(_1544, _328) : _328;                   //对应的云的深度？


    //_328 ： 当前场景的深度
    //_1544 : 检测到的云的深度 > 基础的RayIntersect 距离的话 ？ min(_1544, _328) : _328, 
    //记录云层的修正所导致的深度。

}



//对应的内部线程组为 (8,8,1)
[numthreads(8, 8, 1)]
void main(SPIRV_Cross_Input stage_input)
{
    gl_GlobalInvocationID = stage_input.gl_GlobalInvocationID;
    comp_main();
}
